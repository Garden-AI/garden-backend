# generated by datamodel-codegen:
#   filename:  openapi.json
#   timestamp: 2024-08-12T19:36:54+00:00

from __future__ import annotations

from datetime import date
from enum import Enum
from typing import Any, Literal
from uuid import UUID

from pydantic import BaseModel, Field, RootModel


class LegacyResult(BaseModel):
    subject: str | None = None
    field_version: Any | None = Field("2017-09-01", alias="@version")
    content: Any | None = None
    entry_ids: Any | None = None


class ModernResult(BaseModel):
    subject: str | None = None
    field_version: Any | None = Field("2019-08-27", alias="@version")
    entries: list[dict[str, Any]] | None = None


class GMetaResult(RootModel[LegacyResult | ModernResult]):
    root: LegacyResult | ModernResult


class MetricFacetResult(BaseModel):
    name: str | None = None
    value: float | None = None


class GBucket(BaseModel):
    value: Any | None = None
    count: int | None = None


class BucketFacetResult(BaseModel):
    name: str | None = None
    buckets: list[GBucket] | None = None


class GFacetResult(RootModel[MetricFacetResult | BucketFacetResult]):
    root: MetricFacetResult | BucketFacetResult


class GSearchResult(BaseModel):
    total: int | None = None
    count: int | None = Field(None, description="The length of the 'gmeta' array.")
    gmeta: list[GMetaResult] | None = None
    has_next_page: bool | None = Field(
        None,
        description="True if another page of results is available with pagination.",
    )
    offset: int | None = None
    facet_results: list[GFacetResult] | None = None


class TermsFacet(BaseModel):
    field_name: str = Field(
        ...,
        description="The field to which the facet refers.\nAny dots (`.`) must be escaped with a preceding backslash (`\\`) character.",
        examples=["my_field_name"],
        min_length=1,
    )
    name: str | None = Field(
        None,
        description="A name for this facet which is referenced in the results.\n\nIf `name` is omitted, it will default to the value of the `field_name` property. If more than one facet in a single search request references the same field, a name *must* be provided.",
        min_length=1,
    )
    type: Literal["terms"]
    size: int | None = Field(None, ge=1)


class MetricFacet(BaseModel):
    field_name: str = Field(
        ...,
        description="The field to which the facet refers.\nAny dots (`.`) must be escaped with a preceding backslash (`\\`) character.",
        examples=["my_field_name"],
        min_length=1,
    )
    name: str | None = Field(
        None,
        description="A name for this facet which is referenced in the results.\n\nIf `name` is omitted, it will default to the value of the `field_name` property. If more than one facet in a single search request references the same field, a name *must* be provided.",
        min_length=1,
    )
    type: Literal["sum", "avg"]
    missing: int | None = None


class DateHistogramRange(BaseModel):
    low: Any | None = None
    high: Any | None = None


class DateInterval(Enum):
    year = "year"
    quarter = "quarter"
    month = "month"
    week = "week"
    day = "day"
    hour = "hour"
    minute = "minute"
    second = "second"


class DateHistogramFacet(BaseModel):
    field_name: str = Field(
        ...,
        description="The field to which the facet refers.\nAny dots (`.`) must be escaped with a preceding backslash (`\\`) character.",
        examples=["my_field_name"],
        min_length=1,
    )
    name: str | None = Field(
        None,
        description="A name for this facet which is referenced in the results.\n\nIf `name` is omitted, it will default to the value of the `field_name` property. If more than one facet in a single search request references the same field, a name *must* be provided.",
        min_length=1,
    )
    type: Literal["date_histogram"]
    histogram_range: DateHistogramRange | None = None
    date_interval: DateInterval


class NumericHistogramRange(BaseModel):
    low: float
    high: float


class NumericHistogramFacet(BaseModel):
    field_name: str = Field(
        ...,
        description="The field to which the facet refers.\nAny dots (`.`) must be escaped with a preceding backslash (`\\`) character.",
        examples=["my_field_name"],
        min_length=1,
    )
    name: str | None = Field(
        None,
        description="A name for this facet which is referenced in the results.\n\nIf `name` is omitted, it will default to the value of the `field_name` property. If more than one facet in a single search request references the same field, a name *must* be provided.",
        min_length=1,
    )
    type: Literal["numeric_histogram"]
    size: int = Field(..., ge=1)
    histogram_range: NumericHistogramRange


class GFacet(
    RootModel[TermsFacet | MetricFacet | DateHistogramFacet | NumericHistogramFacet]
):
    root: TermsFacet | MetricFacet | DateHistogramFacet | NumericHistogramFacet = Field(
        ..., discriminator="type"
    )


class GFilterMatchAll(BaseModel):
    type: Literal["match_all"]
    post_filter: bool | None = Field(
        False,
        description="Control whether or not this filter should be applied before or after facets are\ncalculated. If True, the filter will not impact facet results, but will filter the\nquery results.\n\nDefaults to True for all filters except `match_all`, where it defaults to False.\n\nWhen set on nested filters (e.g. under a `not`), only the top-level filter's setting\nis applied.\n",
    )
    field_name: str = Field(..., examples=["my_field_name"], min_length=1)
    values: list = Field(..., min_length=1)


class GFilterMatchAny(BaseModel):
    type: Literal["match_any"]
    post_filter: bool | None = Field(
        True,
        description="Control whether or not this filter should be applied before or after facets are\ncalculated. If True, the filter will not impact facet results, but will filter the\nquery results.\n\nDefaults to True for all filters except `match_all`, where it defaults to False.\n\nWhen set on nested filters (e.g. under a `not`), only the top-level filter's setting\nis applied.\n",
    )
    field_name: str = Field(..., examples=["my_field_name"], min_length=1)
    values: list = Field(..., min_length=1)


class RangeFilterValue(BaseModel):
    from_: Any = Field(..., alias="from")
    to: Any


class GFilterRange(BaseModel):
    type: Literal["range"]
    post_filter: bool | None = Field(
        True,
        description="Control whether or not this filter should be applied before or after facets are\ncalculated. If True, the filter will not impact facet results, but will filter the\nquery results.\n\nDefaults to True for all filters except `match_all`, where it defaults to False.\n\nWhen set on nested filters (e.g. under a `not`), only the top-level filter's setting\nis applied.\n",
    )
    field_name: str = Field(..., examples=["my_field_name"], min_length=1)
    values: list[RangeFilterValue] = Field(..., min_length=1)


class Coordinate(BaseModel):
    lat: float = Field(..., ge=-90.0, le=90.0)
    lon: float = Field(..., ge=-180.0, le=180.0)


class GFilterBoundingBox(BaseModel):
    type: Literal["geo_bounding_box"]
    post_filter: bool | None = Field(
        True,
        description="Control whether or not this filter should be applied before or after facets are\ncalculated. If True, the filter will not impact facet results, but will filter the\nquery results.\n\nDefaults to True for all filters except `match_all`, where it defaults to False.\n\nWhen set on nested filters (e.g. under a `not`), only the top-level filter's setting\nis applied.\n",
    )
    field_name: str = Field(..., examples=["my_field_name"], min_length=1)
    top_left: Coordinate = Field(
        ...,
        description="A coordinate pair is a geographical point, expressed as an object with two keys, `lat`\nand `lon`, for latitude and longitude. The values must be floats, positive or negative,\nwithin the range of acceptable coordinate values: [-90.0, 90.0] for latitude, and\n[-180.0, 180.0] for longitude.\n",
        examples=[{"lat": 40.9, "lon": 87.5}],
    )
    bottom_right: Coordinate = Field(
        ...,
        description="A coordinate pair is a geographical point, expressed as an object with two keys, `lat`\nand `lon`, for latitude and longitude. The values must be floats, positive or negative,\nwithin the range of acceptable coordinate values: [-90.0, 90.0] for latitude, and\n[-180.0, 180.0] for longitude.\n",
        examples=[{"lat": 40.9, "lon": 87.5}],
    )


class Coordinate1(RootModel[list]):
    root: list = Field(
        ...,
        description="A linear ring is a closed series of line segments with three or more positions.\nThe first and last positions must be equivalent.\n\nRings are represented as lists of '[lon,lat]' pairs.\n\nA ring is a simple polygon without holes.\n",
        examples=[
            [[180.0, 40.0], [180.0, 50.0], [170.0, 50.0], [170.0, 40.0], [180.0, 40.0]]
        ],
        min_length=4,
    )


class GeoPolygon(BaseModel):
    type: Literal["Polygon"]
    coordinates: list[Coordinate1] = Field(..., min_length=1)


class GeoShape(RootModel[GeoPolygon]):
    root: GeoPolygon = Field(..., discriminator="type")


class Relation(Enum):
    intersects = "intersects"
    within = "within"


class GFilterGeoShape(BaseModel):
    type: Literal["geo_shape"]
    post_filter: bool | None = Field(
        True,
        description="Control whether or not this filter should be applied before or after facets are\ncalculated. If True, the filter will not impact facet results, but will filter the\nquery results.\n\nDefaults to True for all filters except `match_all`, where it defaults to False.\n\nWhen set on nested filters (e.g. under a `not`), only the top-level filter's setting\nis applied.\n",
    )
    field_name: str = Field(..., examples=["my_field_name"], min_length=1)
    shape: GeoShape
    relation: Relation | None = Field(
        "intersects",
        description="The relationship between the provided shape and the queried field.\n\n'intersects': (default) Return documents whose shape intersects the query shape.\n'within': Return documents whose shape is fully within the query shape.\n",
    )


class GFilterExists(BaseModel):
    type: Literal["exists"]
    post_filter: bool | None = Field(
        True,
        description="Control whether or not this filter should be applied before or after facets are\ncalculated. If True, the filter will not impact facet results, but will filter the\nquery results.\n\nDefaults to True for all filters except `match_all`, where it defaults to False.\n\nWhen set on nested filters (e.g. under a `not`), only the top-level filter's setting\nis applied.\n",
    )
    field_name: str = Field(..., examples=["my_field_name"], min_length=1)


class GBoost(BaseModel):
    field_name: str = Field(..., examples=["my_field_name"], min_length=1)
    factor: float


class Order(Enum):
    asc = "asc"
    desc = "desc"


class GSort(BaseModel):
    field_name: str = Field(..., examples=["my_field_name"], min_length=1)
    order: Order | None = "desc"


class FilterPrincipalSet(RootModel[str]):
    root: str = Field(
        ...,
        description="The name of a 'principal_set' for use in principal set filtering.",
        examples=["admin"],
        max_length=64,
        min_length=3,
        pattern="^[a-z][a-z_-]*[a-z]$",
    )


class ResultFormatVersion(Enum):
    field_2017_09_01 = "2017-09-01"
    field_2019_08_27 = "2019-08-27"


class GScrollResponse(BaseModel):
    total: int | None = None
    count: int | None = Field(None, description="The length of the 'gmeta' array.")
    gmeta: list[GMetaResult] | None = None
    has_next_page: bool | None = Field(
        None,
        description="True if another page of results is available with pagination.",
    )
    marker: Any | None = None


class GMetaEntry(BaseModel):
    subject: str = Field(..., min_length=1)
    id: str | None = Field(None, min_length=1)
    content: dict[str, Any]
    visible_to: list[str] = Field(..., max_length=100, min_length=1)
    principal_sets: dict[str, list[str]] | None = None


class FieldMapping(Enum):
    geo_point = "geo_point"
    geo_shape = "geo_shape"


class GIngestEntry(BaseModel):
    ingest_type: Literal["GMetaEntry"]
    field_mapping: dict[str, FieldMapping] | None = Field(
        None,
        description="A field_mapping explicitly sets the type for fields being  used in the ingest document.\nThe fieldnames are used as keys and their values are the types to which they map.  Dots\nin fieldnames are interpreted as part of the path to a field, but may be escaped with a\nbackslash.\n\nCurrently, only geo datatypes are supported.\n",
        examples=[{"location.center": "geo_point", "location.boundary": "geo_shape"}],
    )
    ingest_data: GMetaEntry


class GMetaList(BaseModel):
    gmeta: list[GMetaEntry] = Field(..., min_length=1)


class GIngestList(BaseModel):
    ingest_type: Literal["GMetaList"]
    field_mapping: dict[str, FieldMapping] | None = Field(
        None,
        description="A field_mapping explicitly sets the type for fields being  used in the ingest document.\nThe fieldnames are used as keys and their values are the types to which they map.  Dots\nin fieldnames are interpreted as part of the path to a field, but may be escaped with a\nbackslash.\n\nCurrently, only geo datatypes are supported.\n",
        examples=[{"location.center": "geo_point", "location.boundary": "geo_shape"}],
    )
    ingest_data: GMetaList


class GIngest(RootModel[GIngestEntry | GIngestList]):
    root: GIngestEntry | GIngestList = Field(..., discriminator="ingest_type")


class TaskSubmitResponse(BaseModel):
    acknowledged: bool | None = Field(
        None, description="Always true for successful task submission."
    )
    task_id: UUID | None = Field(
        None, description="The ID of the task which was just created."
    )


class State(Enum):
    PENDING = "PENDING"
    PROGRESS = "PROGRESS"
    SUCCESS = "SUCCESS"
    FAILED = "FAILED"
    CREATING = "CREATING"


class Task(BaseModel):
    task_id: UUID | None = None
    state: State | None = None
    state_description: str | None = None
    task_type: str | None = None
    index_id: UUID | None = None
    creation_date: date | None = None
    message: str | None = None
    additional_details: Any | None = None
    completion_date: date | None = None


class TaskList(BaseModel):
    index_id: UUID | None = None
    tasks: list[Task] | None = None


class IndexCreate(BaseModel):
    display_name: str = Field(..., description="The name of the index", max_length=128)
    description: str = Field(
        ..., description="A description of the index", max_length=1000
    )


class IndexInfo(BaseModel):
    display_name: str | None = None
    description: str | None = None
    id: UUID | None = None
    max_size_in_mb: int | None = None
    size_in_mb: int | None = None
    num_subjects: int | None = None
    num_entries: int | None = None
    creation_date: date | None = None
    entry_schema: dict[str, Any] | None = None
    subscription_id: UUID | None = None
    is_trial: bool | None = None
    status: str | None = None


class IndexDeleteResponse(BaseModel):
    acknowledged: bool | None = Field(
        None, description="Always true for successful index deletion."
    )
    index_id: UUID | None = Field(
        None, description="The ID of the index which was marked for deletion."
    )


class IndexReopenResponse(BaseModel):
    acknowledged: bool | None = Field(
        None, description="Always true for successful index reopen."
    )
    index_id: UUID | None = Field(
        None, description="The ID of the index which was reopened."
    )


class Permission(Enum):
    owner = "owner"
    admin = "admin"
    writer = "writer"


class IndexWithPermissions(BaseModel):
    display_name: str | None = None
    description: str | None = None
    id: UUID | None = None
    max_size_in_mb: int | None = None
    size_in_mb: int | None = None
    num_subjects: int | None = None
    num_entries: int | None = None
    creation_date: date | None = None
    entry_schema: dict[str, Any] | None = None
    subscription_id: UUID | None = None
    is_trial: bool | None = None
    status: str | None = None
    permissions: list[Permission] | None = None


class IndexListWPermissions(BaseModel):
    index_list: list[IndexWithPermissions] | None = None


class RoleName(Enum):
    owner = "owner"
    admin = "admin"
    writer = "writer"


class PrincipalType(Enum):
    identity = "identity"
    group = "group"


class Role(BaseModel):
    id: str | None = Field(None, description="The ID of the role.")
    role_name: RoleName | None = Field(
        None, description="The name of the role. This implies some set of permissions."
    )
    index_id: UUID | None = None
    principal: str | None = Field(
        None, description="The principal URN for the entity which has this role."
    )
    principal_type: PrincipalType | None = Field(
        None, description="The type of principal encoded by the URN."
    )
    creation_date: date | None = None


class RoleList(BaseModel):
    role_list: list[Role] | None = None


class RoleCreate(BaseModel):
    role_name: RoleName | None = Field(
        None, description="The name of the role. This implies some set of permissions."
    )
    principal: str | None = Field(
        None, description="The principal URN for the entity which has this role."
    )


class DeletedRole(BaseModel):
    deleted: Role | None = None
    success: bool | None = None


class DeleteBySubjectRequest(BaseModel):
    subjects: list[str] = Field(..., min_length=1)


class UGFieldMappings(BaseModel):
    mappings: dict[str, Any] | None = Field(
        None,
        description="A mapping from full field names to their types.",
        examples=[{"foo": "long", "bar.baz": "text"}],
    )


class FieldBudget(BaseModel):
    budget: int | None = Field(
        None, description="The size of the budget for the index."
    )
    used: int | None = Field(
        None,
        description="The amount of the budget which has been used (i.e., budget - remaining).",
    )
    remaining: int | None = Field(
        None, description="The amount of the budget remaining (i.e., budget - used)."
    )


class GFilterNot(BaseModel):
    type: Literal["not"]
    post_filter: bool | None = Field(
        True,
        description="Control whether or not this filter should be applied before or after facets are\ncalculated. If True, the filter will not impact facet results, but will filter the\nquery results.\n\nDefaults to True for all filters except `match_all`, where it defaults to False.\n\nWhen set on nested filters (e.g. under a `not`), only the top-level filter's setting\nis applied.\n",
    )
    filter: GFilter


class GFilter(
    RootModel[
        GFilterMatchAll
        | GFilterMatchAny
        | GFilterRange
        | GFilterBoundingBox
        | GFilterGeoShape
        | GFilterExists
        | GFilterNot
    ]
):
    root: (
        GFilterMatchAll
        | GFilterMatchAny
        | GFilterRange
        | GFilterBoundingBox
        | GFilterGeoShape
        | GFilterExists
        | GFilterNot
    ) = Field(..., discriminator="type")


class GSearchRequestBody(BaseModel):
    q: str | None = Field(None, max_length=256)
    limit: int | None = Field(10, ge=0, le=10000)
    advanced: bool | None = False
    bypass_visible_to: bool | None = Field(
        False,
        description="Set to true to allow this operation to return data with visibility which does not include the current user. Only allowed for index admins and owners.",
    )
    filter_principal_sets: list[FilterPrincipalSet] | None = Field(None, max_length=5)
    offset: int | None = Field(None, ge=0, le=9999)
    result_format_version: ResultFormatVersion | None = Field(
        "2019-08-27",
        description="Used to request results in the legacy (2017-09-01) format",
    )
    facets: list[GFacet] | None = Field(None, max_length=32)
    filters: list[GFilter] | None = Field(None, max_length=32)
    boosts: list[GBoost] | None = Field(None, max_length=16)
    sort: list[GSort] | None = Field(None, max_length=8)


class GScrollRequest(BaseModel):
    q: str | None = Field(None, max_length=256)
    limit: int | None = Field(10, ge=0, le=10000)
    advanced: bool | None = False
    bypass_visible_to: bool | None = Field(
        False,
        description="Set to true to allow this operation to return data with visibility which does not include the current user. Only allowed for index admins and owners.",
    )
    filter_principal_sets: list[FilterPrincipalSet] | None = Field(None, max_length=5)
    filters: list[GFilter] | None = Field(None, max_length=32)
    marker: Any | None = None


GFilterNot.model_rebuild()
